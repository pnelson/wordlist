//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"
)

var (
	s = flag.String("s", defaultSource, "wordlist source url or path")
	o = flag.String("o", "wordlist_eff.go", "output filename")
	t = flag.Duration("t", 90*time.Second, "timeout to fetch remote wordlist")
)

// https://www.eff.org/deeplinks/2016/07/new-wordlists-random-passphrases
const defaultSource = "https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt"

func init() {
	log.SetFlags(0)
}

func main() {
	flag.Parse()
	rc, err := fetch(*s, *t)
	if err != nil {
		log.Fatal(err)
	}
	defer rc.Close()
	err = write(rc, *o)
	if err != nil {
		log.Fatal(err)
	}
}

func fetch(source string, timeout time.Duration) (io.ReadCloser, error) {
	f, err := os.Open(source)
	if err != nil {
		return fetchHTTP(source, timeout)
	}
	return f, nil
}

func fetchHTTP(url string, timeout time.Duration) (io.ReadCloser, error) {
	client := &http.Client{Timeout: timeout}
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("User-Agent", "github.com/pnelson/wordlist")
	req.Header.Set("Content-Type", "text/plain")
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != http.StatusOK {
		err = fmt.Errorf("wordlist: fetch status %v", resp.StatusCode)
	}
	return resp.Body, err
}

func write(r io.Reader, filename string) error {
	var buf bytes.Buffer
	buf.WriteString("// generated by wordlist_eff_gen.go\n\n")
	buf.WriteString("package wordlist\n")
	buf.WriteString("var eff = []string{\n")
	max, err := flush(r, &buf)
	if err != nil {
		return err
	}
	buf.WriteString("}\n\nconst maxWordLength = " + strconv.Itoa(max) + "\n")
	data, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return os.WriteFile(filename, data, 0644)
}

func flush(r io.Reader, buf *bytes.Buffer) (int, error) {
	s := bufio.NewScanner(r)
	max := 0
	for s.Scan() {
		line := s.Text()
		parts := strings.SplitN(line, "\t", 2)
		if len(parts) != 2 {
			continue
		}
		word := parts[1]
		length := len(word)
		if length > max {
			max = length
		}
		buf.WriteString("\"" + word + "\",\n")
	}
	return max, s.Err()
}
